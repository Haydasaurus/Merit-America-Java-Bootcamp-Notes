# Outer joins

Take a look at the `city` and `country` tables again:

**country**

| **country_id** | **name** |
| -------------- | -------- |
| 1              | Canada   |
| 2              | Mexico   |
| 3              | Cuba     |
| 4              | France   |
| 5              | Spain    |
| 6              | Italy    |
| 7              | China    |

**city**

| **city_id** | **country_id** | **name** |
| ----------- | -------------- | -------- |
| 1           | 6              | Milan    |
| 2           | 6              | Rome     |
| 3           | 7              | Beijing  |
| 4           | 4              | Nice     |
| 5           | 4              | Paris    |
| 6           | 1              | Toronto  |
| 7           | 5              | Seville  |

You can join these tables to see countries and their cities:

```sql
SELECT country.name AS "Country", city.name AS "City"
FROM country 
JOIN city ON country.country_id = city.country_id;
```

These are the results:

| **Country** | **City** |
| ----------- | -------- |
| Italy       | Milan    |
| Italy       | Rome     |
| China       | Beijing  |
| France      | Nice     |
| France      | Paris    |
| Canada      | Toronto  |
| Spain       | Seville  |

Notice that the countries Mexico and Cuba are missing from the list. That's because there are no cities which reference those countries. The operation you performed is technically known as an **inner join**. For this type of join, the database returns a row for _every match_ of the rows in the first table (`country`) and second table (`city`). If there is no match, there is no row returned. So Cuba and Mexico drop out of the result.

When you specify `JOIN` in your SQL statement, you're asking for an inner join. It's the same as if you typed this:

```sql
FROM country 
INNER JOIN city ON country.country_id = city.country_id
```

But what if you want to see _all_ countries, regardless of whether there's a corresponding city in the database? For this, you use an **outer join**. For an outer join, you ask the database for _all_ the rows in one table (whether there is a match or not), plus the matching rows in another table.

SQL uses the terminology "left" and "right" to describe the two tables. SQL calls the _first_ table the _left_ table (the one named to the left of `JOIN`), and the _second_ table the _right_ table. If it helps, think of the entire SQL query as one long line of text. Then "left" and "right" makes some sense. If you want all the rows in the left table, you use a **left outer join**:

```sql
SELECT country.name AS "Country", city.name AS "City"
FROM country 
LEFT OUTER JOIN city ON country.country_id = city.country_id;
```

Now you see results that include the other two countries:

| **Country** | **City** |
| ----------- | -------- |
| Italy       | Milan    |
| Italy       | Rome     |
| China       | Beijing  |
| France      | Nice     |
| France      | Paris    |
| Canada      | Toronto  |
| Spain       | Seville  |
| Mexico      | (null)   |
| Cuba        | (null)   |

Mexico and Cuba are listed, but since there is no matching city, _the columns from the city table show null values_. This indicates that there was no match.

A **right outer join** applies the same principal, except that it returns all rows from the _right_ table (the table _after_ the `JOIN` clause), plus the matching rows from the left table.

What if you want to find all the countries which _do not_ have a city in the database? You can modify this query to test for null in a `city` column. You can test on any column in the `city` table, but it's best to use the primary key:

```sql
SELECT country.name AS "Country"
FROM country 
LEFT OUTER JOIN city ON country.country_id = city.country_id
WHERE city.city_id IS NULL;
```

Result:

| **Country** |
| ----------- |
| Mexico      |
| Cuba        |