# Data access

You've learned that applications use relational databases to store data. You've also learned how to write SQL statements to read and modify data in a database. But how do Java applications interact with a database?

## Java data access layers

To perform interactions with a databaseâ€”such as creating a connection and sending SQL statementsâ€”Java provides a stack of data access layers, as shown in the diagram:

![Data Access](https://user-images.githubusercontent.com/94882786/176063014-6653c0de-edc4-427f-9066-8825e013d7b6.png)

The lowest layer is the **Java Database Connectivity**, more commonly known as **JDBC**. JDBC is the API by which Java can access many different data sources including relational databases, spreadsheets, and flat files. There are two components to JDBC: the **JDBC Driver** and the API itself.

The API is database-neutral, meaning it's unaware of the specific underlying database. It submits SQL and retrieves results without detecting whether the database is PostgreSQL, SQL Server, Oracle, or something entirely different. To handle the difference between the neutrality of the API and a specific database, a JDBC Driver is inserted between the two.

Each database has its own JDBC Driver, or _database driver_. In other words, there are database drivers for PostgreSQL, Microsoft SQL Server, Oracle, and many more. The database driver is responsible for communication between the database-neutral API and the specific database the driver is intended for.

The selection and configuration of the database driver is typically addressed when you first create a Java project. The API is located in the Java packages `java.sql` and `javax.sql`. These packages can be imported into any class that needs to communicate with a database.

**Spring JDBC JdbcTemplate**

While JDBC allows Java applications to communicate with databases, its API requires you to manage many low-level details such as opening and closing database connections, handling exceptions, and transferring data between Java and the database. Writing code using the API can become tedious and error-prone.

Fortunately, Spring JDBC provides a class called the [`JdbcTemplate`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html) that makes working with SQL relational databases and JDBC much easier. `JdbcTemplate` abstracts away many of the details, which allows you to concentrate on your application's needs.

## Connection strings

Before you can send SQL statements to a database, you must set up a connection to the database. A connection provides a way for the database server and your application to communicate with each other.

You must have a **connection string** to establish the connection. A connection string contains information about the database. It follows a standard URL format:

```java
jdbc:postgresql://SERVER_NAME:PORT/DATABASE_NAME
```

-   `jdbc`: the protocol is JDBC.
-   `postgresql`: the driver name. (This curriculum uses PostgreSQL for Java.)
-   `SERVER_NAME`: the host name or IP address of the database server.
-   `PORT`: The port number of the database server.
-   `DATABASE_NAME`: the name of the database on the server.

The interface [`DataSource`](https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html) uses the connection string internally. Since `DataSource` is an interface, you must provide an implementation. One of the more popular implementations is the Apache Commons DBCP library [`BasicDataSource`](https://commons.apache.org/proper/commons-dbcp/apidocs/org/apache/commons/dbcp2/BasicDataSource.html) . Once you create an instance of `BasicDataSource`, you need to bind your connection string to it using the `setURL()`.

In the following example, the application connects to a PostgreSQL database named `bookstore` at the beginning of `run()`:

```java
package com.techelevator;

import org.apache.commons.dbcp2.BasicDataSource;

public class BookstoreApp {

    public static void main(String[] args) {

        BookstoreApp bookstoreApp = new BookstoreApp();
        bookstoreApp.run();

    }

    private void run() {

        // Instantiate datasource and set connection string
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:postgresql://localhost:5432/bookstore");

    }

}
```

### Security

Modern databases typically require credentials such as a username and password for all connections regardless of its source. However, if you look at the connection string example again, you'll notice there are no credentials included:

```java
jdbc:postgresql://SERVER_NAME:PORT/DATABASE_NAME
```

Set the connection credentials on the `dataSource` as the following code sample shows:

```java
private void run() {

    // ...
    dataSource.setUrl("jdbc:postgresql://localhost:5432/bookstore");
    // Set connection credentials
    dataSource.setUsername("postgres");
    dataSource.setPassword("postgres1");

}
```

>**âš  Warning: Don't store plain text passwords in code**
>
>Storing plain text passwords in code isn't a good idea and is only done here to reduce complexity. There are ways to externalize these properties which you'll learn about later on.

## Connection objects

As mentioned earlier, Spring JDBC's `JdbcTemplate` helps with using JDBC, so create an instance immediately after setting up the `dataSource`:

```java
private void run() {

    // ...
    dataSource.setPassword("postgres1");

    // Create an instance of JdbcTemplate, and bind the datasource
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);

}
```

One of the key reasons for using `JdbcTemplate` over the lower-level APIs is that you don't have to concern yourself with managing the connections to the database. `JdbcTemplate` opens and closes any required connections whenever you perform a query or any other SQL action.

---

# Running SQL statements

The examples given throughout the rest of this unit involve the `author` and `book` tables in the `bookstore` database. The following diagram shows the ERD for the database.

![Bookstore database](https://user-images.githubusercontent.com/94882786/176063092-e325b5b1-6bd7-4add-838f-77d5f748dc77.svg)

The relationship between the two tables is a one-to-many, with an author having from zero-to-many books, and a book always having one author.

## Submitting queries

Now that you can open connections to the database, you can send it SQL statements. There are various methods in the `JdbcTemplate` class you can use depending on what you want to do. The following are several of the most commonly used ones:

| Name               | Description                                                                            |
| ------------------ | -------------------------------------------------------------------------------------- |
| `queryForRowSet()` | Execute a query for a SqlRowSet.                                                       |
| `queryForObject()` | Execute a query for a result object.                                                   |
| `update()`         | Execute a single SQL update operation (such as an INSERT, UPDATE or DELETE statement). |

Imagine a scenario where a user wants to retrieve all of the books from the `book` table. To achieve this, you can use the `queryForRowSet()` method, which takes the SQL to execute as an argument:

```java
private void run() {

    // ...
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);

    /*
     Best practice is to assign the SQL string to a variable, and
     then pass the variable to the JdbcTemplate method.
     It makes for more readable and consequently maintainable code.
    */
    String sql = "SELECT book_id, title, author_id, " +
            "price, publish_date, out_of_print FROM book;";
    SqlRowSet results = jdbcTemplate.queryForRowSet(sql);

}
```

This returns a [`SqlRowSet`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/support/rowset/SqlRowSet.html) , which you use to iterate over the results.

## Reading query results

Reading the results from a `SqlRowSet` is like reading input from a `Scanner` in File I/O. You'll loop through the results in a `while` loop using the `next()` method of the `SqlRowSet`. When you call the `next()` method, the `SqlRowSet` moves to the next row of the result set. It returns `true` when it successfully moves to a row. It returns `false` if there are no more rows to read:

```java
private void run() {

    // ...
    SqlRowSet results = jdbcTemplate.queryForRowSet(sql);

    // Loop through all the rows returned
    while (results.next()) {

        // ...

    }
}
```

The `SqlRowSet` has many methods for retrieving column values from a row and converting them to the corresponding Java types. Each method takes the name of the column to retrieve. Most of the methods have self-explanatory names.

For instance, `getInt("book_id")` retrieves the value from the `book_id` column (a database `integer`) and returns a Java `int`. `getString("title")` does the same thing, but for the `title` column (a database `varchar`) and a Java `String`:

```java
private void run() {

    // ...
    SqlRowSet results = jdbcTemplate.queryForRowSet(sql);

    // Loop through all the rows returned
    while (results.next()) {

        // Simple mapping of columns to variables
        int bookId = results.getInt("book_id");
        String title = results.getString("title");
        int authorId = results.getInt("author_id");
        BigDecimal price = results.getBigDecimal("price");
        LocalDate publishDate = null;
        if (results.getDate("publish_date") != null) {
            publishDate = results.getDate("publish_date").toLocalDate();
        }
        boolean isOutOfPrint = results.getBoolean("out_of_print");
        System.out.println("Book{" +
                "id: " + bookId + ", title: " + title + ", price: " + price +
                "date published: " + publishDate + ", out of print: " + isOutOfPrint + "}");

    }

}
```

Two methods in the previous code sample need special mention: `getBigDecimal()` and `getDate()`:

```java
// ...
BigDecimal price = results.getBigDecimal("price");
LocalDate publishDate = null;
if (results.getDate("publish_date") != null) {
    publishDate = results.getDate("publish_date").toLocalDate();
}
// ...
```

### Money

The rounding problems inherent with floating-point values aren't limited to Java aloneâ€”they apply to databases as well. You must be careful whenever floating-point values represent money.

The preferred way to define "money" columns in PostgreSQL is to use the `numeric(precision, scale)` type with `precision` being the total number of digits, and `scale` being the number of digits to the right of the decimal point.

>ðŸ›ˆ Note: Numeric precision and scale
>
>The number of digits given in `scale` is included in the total number of digits, so the `book.price` column in the `bookstore` database defined as `numeric(10,2)` can contain a maximum value of 99,999,999.99.
>
>The exact `precision` and `scale` varies from company to company. As a general rule, when defining maximum monetary values, err on the side of too large rather than too small.

`BigDecimal` is the preferred type for money amounts in Java, so the example code uses `getBigDecimal("price")` to retrieve the `numeric(10,2)` database value and convert it to a Java `BigDecimal`:

```java
BigDecimal price = results.getBigDecimal("price");
```

### Date and time

PostgreSQL has three date and time types:

| **Type**  | **Description**       |
| --------- | --------------------- |
| timestamp | both date and time    |
| date      | date (no time of day) |
| time      | time of day (no date) |

Fortunately, Java has corresponding `LocalDateTime`, `LocalDate`, and `LocalTime` types, and conversion methods appropriate for each type:

| **Database type** | **Java type** | **Conversion method** |
| ----------------- | ------------- | --------------------- |
| timestamp         | LocalDateTime | toLocalDateTime()     |
| date              | LocalDate     | toLocalDate()         |
| time              | LocalTime     | toLocalTime()         |

Since the `getDate` method returns a `java.sql.Date`, the example code adds `.toLocalDate()` to `getDate("publish_date")` to convert that to a Java `LocalDate`:

```java
LocalDate publishDate = null;
if (results.getDate("publish_date") != null) {
    publishDate = results.getDate("publish_date").toLocalDate();
}
```

### Database nulls

As you know, database columns can contain null values if they're not defined as `NOT NULL`. This can result in Java throwing `NullPointerException`s if you aren't careful.

Look back at the previous ERD and note that `publish_date` allows nulls. If you call `toLocalDate()` directly on the Java `Data` object returned by `results.getDate("publish_date")`, you run the risk of calling the method on a null object and throwing a `NullPointerException`:

```java
LocalDate publishDate = results.getDate("publish_date").toLocalDate();
```

If the row's `publish_column` column has a null value, `getDate("publish_date")` returns null to Java. _You can't call methods on a null object._

To avoid the problem, always check for null if the column allows nulls in the database before calling a method on it:

```java
LocalDate publishDate = null;
if (results.getDate("publish_date") != null) {
    publishDate = results.getDate("publish_date").toLocalDate();
}
```

This isn't required if the value is assigned to a primitive data type, like `isOutOfPrint`:

```java
boolean isOutOfPrint = results.getBoolean("out_of_print");
```

Nulls are automatically converted to the primitive's zero-value.

## Mapping results to objects

The previous example shows the basic code to retrieve values from a database row, but having several disjointed variables isn't useful. It's difficult to keep them in sync so they contain the values from a single row. Passing around those variables also takes time. It would be less time-consuming and more object-oriented to store the values from a single row in a single object.

A common technique with JDBC is to create a model class representing a database table, and a mapping method which creates a new instance of the model, retrieves values from the `SqlRowSet`, assigns them to the attributes of the new instance, and then returns the fully instantiated object when complete.

### The "model" class

A model class is a POJO (plain old Java object) with attributes that match columns in the table it represents. A model class may also have additional attributes and methods for its own purposes.

For example, the `author` table has `author_id`, `first_name`, and `last_name` columns. Consequently, the `Author` model class has three attributes, `authorId`, `firstName`, and `lastName`, along with the getters and setters for each attribute, and a `toString` method:

```java
public class Author {

    // Private attributes that correspond to columns
    private int authorId;
    private String lastName;
    private String firstName;

    // ... public getters/setters not shown

    // Not required, but toString() override frequently added as a convenience
    @Override
    public String toString() {
        return "Author{" + "authorId=" + authorID + ", lastName='" + lastName + '\'' + ", firstName='" + firstName + '\'' +  '}';
    }
}
```

The `book` model class isn't shown here, but it follows a similar construction as the `Author` class in terms of the correspondence between table columns and model attributes.

### Mapping method

The mapping method takes a `SqlRowSet` as its single argument. It creates a new instance of the model, sets the instance attributes with database values from the current row in the row set, and returns the fully instantiated object:

```java
private Book mapRowToBook(SqlRowSet results) {
    Book book = new Book();
    book.setBookId(results.getInt("book_id"));
    book.setTitle(results.getString("title"));
    book.setAuthorId(results.getInt("author_id"));
    book.setPrice(results.getBigDecimal("price"));
    if (results.getDate("publish_date") != null) {
        book.setPublishDate(results.getDate("publish_date").toLocalDate());
    }
    book.setOutOfPrint(results.getBoolean("out_of_print"));
    return book;
}
```

### Using the model and the mapping method together

The model and the mapper encapsulate their code which helps to clean up the application code when they're used together:

```java
private void run() {

    // ...
    SqlRowSet results = jdbcTemplate.queryForRowSet(sql);

    // Loop through all the rows returned
    while (results.next()) {

        // ...

        // Map a row to database model
        Book book = mapRowToBook(results);
        System.out.println(book);

    }

}
```

## Single value result

Occasionally, you may want only one value from the databaseâ€”perhaps the number of rows in a particular table, or the sum of a particular column.

If you want to get back a single object, you can use the `queryForObject()` method in the `JdbcTemplate` class. This method executes a query for and maps a single row or column to a given object type.

The following example selects the count of all the books in the book table, and returns the results as an `int` value:

```java
private void run() {

    // ...
    while (results.next()) {
        // ...
    }

    // Query for a single Integer value (Integer.class)
    int count = jdbcTemplate.queryForObject("SELECT count(*) FROM book;", int.class);
    System.out.println("Book count: " + count);

}
```

---

# SQL statement parameters

So far, the examples have used static SQL, but imagine a scenario where a user wants to find records that match a certain condition. For instance, a user might want to find all the books written by Ted Chiang. The SQL query looks like this:

```sql
SELECT * FROM book
JOIN author ON author.author_id = book.author_id
WHERE first_name = 'Ted' AND last_name = 'Chiang';
```

However, another user is interested in finding all of Ursula Le Guin's novels and collections:

```sql
SELECT * FROM book
JOIN author ON author.author_id = book.author_id
WHERE first_name = 'Ursula' AND last_name = 'Le Guin';
```

## Using SQL parameters

It's impractical to write static SQL statements for each author. SQL parameters are the answer.

If you need to insert one or more values into your SQL, you use question marks (`?`) to denote placeholders for the actual values:

```sql
SELECT * FROM book
JOIN author ON author.author_id = book.author_id
WHERE first_name = ? AND last_name = ?;
```

In this example, the `?`s are placeholders for the `first_name` and `last_name` values that are passed in from Java along with the SQL when calling `queryForRowSet()`:

```java
private void run() {

    // ...
    System.out.println("Book count: " + count);

    String authorBooksSql =
        "SELECT * FROM book " +
        "JOIN author ON author.author_id = book.author_id " +
        "WHERE first_name = ? AND last_name = ?;";
    // Include the author's first and last names to provide values for the placehalders
    SqlRowSet authorBooksResults =
        jdbcTemplate.queryForRowSet(authorBooksSql, "Ted", "Chiang");
    while (authorBooksResults.next()){
        Book book = mapRowToBook(authorBooksResults);
        System.out.println(book);
    }

}
```

You must supply a value for every placeholder in the SQL, even if they're repeating values. For instance, perhaps you're writing a query to find houses for sale within a certain price range. The seller has a low-high range, as does the buyer. The `WHERE` clause needs to find houses where the buyer's low-high overlaps the seller's range:

![Buyer's price range overlap](https://user-images.githubusercontent.com/94882786/176064116-0da50d59-c4dd-4de8-aa00-d6c92fb1d2f5.png)

```java
String findHouseSql =
    "SELECT * FROM house " +
    "WHERE (? <= house.high_price AND ? >= house.low_price) AND (? < ?);";
SqlRowSet findHouseResults =
    jdbcTemplate.queryForRowSet(findHouseSql, buyerLow, buyerHigh, buyerLow, buyerHigh);
```

Since the SQL also validates that the buyer's low offer is less than their high offer, it contains four placeholders. The call to `queryForRowSet()` includes four values in addition to the SQL itself, two `buyerLow` values alternating with two `buyerHigh` values.

>**ðŸ›ˆ Note: Java's powerful placeholders**
>
>Not only do the `?`s serve as placeholders, but Java adds an extra power. The values passed in from Java are automatically wrapped with their appropriate SQL delimiters: `"Ted"` becomes `'Ted'` and `"Chiang"` is wrapped as `'Chiang'`.
>
>Even Java strings with embedded apostrophes are correctly transformed. For example, the book title `"Farnham's Freehold"` is translated to `'Farnham''s Freehold'`.
>
>Date and time values are similarly wrapped.
>
>### !callout-info
>
>## Tip: Why not concatenate?
>
>You've learned about string concatenation, and you might wonder why you can't put the user input directly into the query. For instance:
>
>```java
>String firstName = "Ted";
>String lastName = "Chiang";
>String authorBooksSql =
>    "SELECT * FROM book " +
>    "JOIN author ON author.author_id = book.author_id " +
>    "WHERE first_name = '" + firstName + "' " +
>        "AND last_name = '" + lastName + "';";
>```
>
>This is discussed in a future unit, but using parameters is one way to prevent malicious users from using **SQL injection** to access data they shouldn't be able to, or even execute commands that can destroy your data.  
  >
>In addition, you also must remember to delimit strings, dates, and times with single quotes and to format dates and times correctly when building the concatenated SQL string. **_Note the single quotes around the `firstName` and `lastName` when building the previous `authorBookSQL` string._** Placeholders take care of these tasks for you.

## A second example: single row results

Another common use of placeholders is to retrieve a single record from a table using its primary key. There's nothing unusual with the placeholder in this example, but handling the results is different:

```
// Retrieving a single book by its primary key
String getBookByIdSql = "SELECT * FROM book WHERE book_id = ?;";
SqlRowSet bookResults = jdbcTemplate.queryForRowSet(getBookByIdSql, 6);
if (bookResults.next()) {
    // Only expect one book, so a single if-next() confirms
    Book book = mapRowToBook(bookResults);
    System.out.println(book);
}
else {
    // Zero books back from database -- how to handle depends upon context
    System.out.println("Book by id not found.");
}
```

When all the results from a query need to be processed, you use a `while` loop, but sometimes an `if (results.next())` is enough. An example might be when you only expectâ€”or only needâ€”one record to be returned, or when you need to know whether any results were returned, as is the case here. **_It's best to always confirm a matching record was found._**

## The final example: SQL `ILIKE` with wildcards, Java `List<>`, and nulls

This example demonstrates using wildcards with placeholders and SQL `ILIKE`, gathering up results in a Java `List<>` , and handling attributes which are potentially null.

In addition to retrieving books by the author's name, and a single book by its primary key, you want the users to be able to find book by titles using a search term. The search uses SQL `ILIKE` which ignores case and permits the use of wildcards. The search term is surrounded by wildcards in code such that "and" becomes "%and%" and matches "and" anywhere within a `book.title`:

```java
// Searching for book titles with wildcards
String findTitleSql = "SELECT * FROM book WHERE title ILIKE ?;";
// User search term is assumed to not have wildcards
String searchTerm = "and";
// Surround searchTerm with wildcards front-and-back`
String termWithWildcards = "%" + searchTerm + "%";
// "%and%" will be correctly wrapped with single-quotes by placeholder as '%and%'
SqlRowSet findTitleResults =
    jdbcTemplate.queryForRowSet(findTitleSql, termWithWildcards);
// Build a list of books rather than processing each book within the while-next() loop
List<Book> books = new ArrayList<>();
while (findTitleResults.next()) {
    Book book = mapRowToBook(findTitleResults);
    // Add the book to the list
    books.add(book);
}
// The list is built, now do something with books on a book-by-book basis
BigDecimal totalPrice = new BigDecimal("0.00");
for (Book book : books) {
    // Since price column is nullable, make sure price attribute isn't null before adding
    if (book.getPrice() != null) {
        totalPrice = totalPrice.add(book.getPrice());
    }
    System.out.println(book);
}
System.out.println(totalPrice);
```

Building the `List<Book>` in code isn't any different than code you've encountered in the past. The only difference is that the call to `mapRowToBook` transforms the database row into a `Book` object.

Finally, since any nullable database column can potentially set its corresponding model reference type attribute to null, it's necessary to check `Big Decimal price` attribute for null before calling `add()`.

---

# Modifying data

There's more to SQL than reading data. In addition to basic querying with `SELECT`, SQL offers `INSERT`, `UPDATE`, and `DELETE` statements. Together, the four types of statements are frequently referred to as **CRUD** operations.

>**ðŸ›ˆ Note: What is CRUD?**
>
>**C**reate, **R**ead, **U**pdate, and **D**elete are the four basic operations of persistent storage. In terms of SQL, here's how the operations match up:
>
>| **CRUD operation** | **SQL statement** |
>| ------------------ | ----------------- |
>| Create             | `INSERT`          |
>| Read               | `SELECT`          |
>| Update             | `UPDATE`          |
>| Delete             | `DELETE`          |

## Create

The code for modifying SQL data follows the same outline that's been used with the previous `SELECT` examples: create the SQL string, and then call a `JdbcTemplate` method.

For `INSERT`, the SQL has a `RETURNING` clause so the value of the primary key of the new record is returned. To retrieve the primary key, `queryForObject()` is called, which transforms the value into an `int` with the `Integer.class` argument.

The example code is a bit longer than most:

```java
/*
 Add a new author and book to the database.
 It is a common practice to create and populate instances of a model
 prior to adding them to the database.
 */
Author author = new Author();
author.setLastName("Bester");
author.setFirstName("Alfred");
String createAuthorSql =
    "INSERT INTO author (first_name, last_name) VALUES (?, ?) RETURNING author_id;";
// Insert the new Author, and hold onto the returned auto-increment value of author_id
int authorId =
    jdbcTemplate.queryForObject(createAuthorSql, int.class, author.getFirstName(),
                                author.getLastName());
// Set the authorId attribute of the Author object to the authorId returned.
author.setAuthorId(authorId);
System.out.println(author);
/*
 Add a new book to the author just added.
 Note the use of the authorId to relate the book with the author.
 */
Book book = new Book();
book.setTitle("The Demolished Man");
book.setOutOfPrint(true);
book.setAuthorId(authorId); // Relate the author to the book by setting the authorId
String createBookSql =
    "INSERT INTO book (title, author_id, price, publish_date, out_of_print) " +
        "VALUES (?, ?, ?, ?, ?) RETURNING book_id;";
// Insert the new book, and hold onto the returned auto-incremented value of book_id
int bookId =
    jdbcTemplate.queryForObject(createBookSql, int.class, book.getTitle(),
        book.getAuthorId(), book.getPrice(), book.getPublishDate(), book.isOutOfPrint());
// Set the bookId attribute of the Book object to the bookId returned
book.setBookId(bookId);
System.out.println(book);
```

In addition to creating a new author, the sample code also creates a new book, and demonstrates how the primary key returned by the `INSERT` of the author is used to relate the book to the author when the book is inserted into the `book` table.

There are several other things to note in the code sample. First, both the author and book inserts assume an instance of their respective models have been created and populated. As you'll see in the next lesson on the DAO pattern, model objects are a convenient way to pass in values when creating and updating the database.

Second, neither the `author.author_id` nor the `book.book_id` primary key column values are part of the `INSERT` statement. Both columns are defined as `SERIAL` in the database, so the database sets their values automatically. _Avoid providing values for auto-incremented columns overrides the values established by the database as this can lead to unexpected behavior._

Finally, the primary keys returned by the call to `queryForObject()` set the values for the `authorId` and `bookId` attributes of the `Author` and `Book` objects respectively since the auto-incremented values aren't known until after the insert.

## Update

The `price` attribute of the `book` object wasn't set in the prior example. The following example code fixes this:

```java
// Update the price and publish date of the newly added book
book.setPrice(new BigDecimal("11.10"));
book.setPublishDate(LocalDate.of(2013, 05, 28));
String updateBookSql =
    "UPDATE book SET title = ?, author_id = ?, price = ?, " +
        "publish_date = ?, out_of_print = ? WHERE book_id = ?;";
int numberOfRowsUpdated =
    jdbcTemplate.update(updateBookSql, book.getTitle(), book.getAuthorId(),
        book.getPrice(), book.getPublishDate(), book.isOutOfPrint(), book.getBookId());
// Since updated record using primary key, expect only one record updated.
if (numberOfRowsUpdated == 1) {
    System.out.println(book);
}
else {
    System.out.println("Update of book failed.");
}
```

It assumes the instance of the `book` model is still in scope and begins by setting its price attribute.

Next, it uses the `JdbcTemplate` method, `update()` which takes the SQL string, and as many values as there are placeholders in the SQL. This includes the `book.bookID` attribute as the last of the values passed in. It's used in the `WHERE` to limit the update to one record identified by its primary key. `update()` returns the number of rows updated. If no rows were changed, it returns zero. The `numberOfRowsUpdated` is checked to confirm just one record was updated.

## Delete

Performing a basic delete operation is similar to performing an update operation. Deleting can become more complex, however, when foreign key constraints are involved. For example, to remove an author from the bookstore database, you must first delete all the books related to the author in the `book` table because they have a foreign key constraint on `author_id`:

```java
// Delete the new author and any related books
String deleteBookSql = "DELETE FROM book WHERE author_id = ?;";
// Delete all the books related to the
int numberOfRowsDeleted = jdbcTemplate.update(deleteBookSql, author.getAuthorId());
// Safe to delete the author
String deleteAuthorSql = "DELETE FROM author WHERE author_id = ?;";
numberOfRowsDeleted = jdbcTemplate.update(deleteAuthorSql, author.getAuthorId());
if (numberOfRowsDeleted == 1) {
    System.out.println("Author was safely deleted");
}
else {
    System.out.println("Author delete failed.");
}
```

In other words, _you must always remove all foreign key references to a primary key in other tables before you can remove a record from a table where it's the primary key._ Due to the constraint, a crucial part of the following example is the order in which records are deleted.

---

# DAO pattern

The Java code in the previous examples demonstrates the fundamentals of database access with Spring JDBC. Using Spring JDBC in isolation, however, is just a linear sequence of Java statements without any real organization other than some clustering of related statements. There's nothing especially object-oriented about that approach. Fortunately, there's a useful and widely recognized way to organize your database access code.

One of the major outcomes of object-oriented programming has been the growth of **software design patterns**. While applications differ, they share many of the same challenges, such as accessing databases, logging audit information, and passing objects back and forth internally and in communication with other applications.

Over time, developers have created and shared descriptive solutions to these challenges. The solutions aren't code that you can drop into your application; rather they're templates with guidance on how to solve problems. Each template is a design pattern that offers a solution for a common challenge.

In particular, the **DAO pattern** is the one that can transform your database access code into something more useful.

**DAO** stands for **Data Access Object**, which is the name given to a set of classes and interfaces that facilitates interactions with a data source, as the following diagram shows:

![DAO pattern](https://user-images.githubusercontent.com/94882786/176065690-4d087dcd-7fb4-4fd1-841e-18774b6ec651.png)

The first thing to notice in the diagram is the interaction between the application and the DAO. The application and DAO exchange models and values. The application can't detect what data sources lie on the other side of the DAO interface. If the application wants a piece of information, it calls one of the DAO's `GET` methods. If it wants to persist an object, it calls the DAO's `UPDATE` method. Since the application and the DAO are both written in Java, the models and values are Java models and values.

The various implementations of the DAO interface handle transforming and transferring the Java models and values back and forth with its underlying data source. The DAO pattern doesn't require any particular implementation of a DAO, and the "jdbc", "file", and "service" DAOs shown are only some of the possibilities.

As discussed previously, it's common to have models which map directly to database tables in JDBC, and in the DAO pattern, it's common to have separate DAOs for each model. For instance, `Book` and `Author` models have corresponding `BookDao` and `AuthorDao` interfaces. In turn, each DAO has at least one implementation based on a specific data source. In this case, the `bookstore` database, hence `JdbcBookDao` and `JdbcAuthorDao`.

As an example, the following code shows a DAO interface and JDBC implementation for the `Author` model which supports the CRUD operations, and a basic demonstration of using the `AuthorDAO` in an application.

```java
// AuthorDao.java
public interface AuthorDao {

    Author getAuthor(int authorId);

    List<Author> getAllAuthors();

    Author createAuthor(Author author);

    boolean updateAuthor(Author author);

    void deleteAuthor(int authorId);

}

// JdbcAuthorDao.java
public class JdbcAuthorDao implements AuthorDao {

    private final JdbcTemplate jdbcTemplate;

    public JdbcAuthorDao(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Author getAuthor(int authorId) {
        Author author = null;
        String sql =
            "SELECT author_id, first_name, last_name FROM author " +
            "WHERE author_id = ?;";
        SqlRowSet results = jdbcTemplate.queryForRowSet(sql, authorId);
        if (results.next()) {
            // Only expect one book, so a single if-next() confirms
            author = mapRowToAuthor(results);
        }
        return author;
    }

    @Override
    public List<Author> getAllAuthors() {
        List<Author> authors = new ArrayList<>();
        String sql = "SELECT author_id, first_name, last_name FROM author;";
        SqlRowSet results = jdbcTemplate.queryForRowSet(sql);
        while (results.next()) {
            // Only expect one book, so a single if-next() confirms
            authors.add(mapRowToAuthor(results));
        }
        return authors;
    }

    @Override
    public Author createAuthor(Author author) {
        String sql = "INSERT INTO author (first_name, last_name) " +
                     "VALUES (?, ?)  RETURNING author_id;";
        int authorId =
            jdbcTemplate.queryForObject(sql, Integer.class, author.getFirstName(),
                author.getLastName());
        // Set the authorId attribute of the Author object to the authorId returned.
        author.setAuthorId(authorId);
        return author;
    }

    @Override
    public boolean updateAuthor(Author author) {
        String sql = "UPDATE author SET first_name = ?, last_name = ? " +
                     "WHERE author_id = ?;";
        int numberOfRows =
            jdbcTemplate.update(sql, author.getFirstName(), author.getLastName(),
                author.getAuthorId());
        return numberOfRows == 1;
    }

    @Override
    public void deleteAuthor(int authorId) {
        // Delete foreign key references to authorID
        String deleteBookSql = "DELETE FROM book WHERE author_id = ?;";
        jdbcTemplate.update(deleteBookSql, authorId);
        // Now safe to delete the author
        String deleteAuthorSql = "DELETE FROM author WHERE author_id = ?;";
        jdbcTemplate.update(deleteAuthorSql, authorId);
    }

    private Author mapRowToAuthor(SqlRowSet results) {
        Author author = new Author();
        author.setAuthorId(results.getInt("author_id"));
        author.setFirstName(results.getString("first_name"));
        author.setLastName(results.getString("last_name"));
        return author;
    }
}

// BookstoreApp.java
public class BookstoreApp {

    public static void main(String[] args) {
        BookstoreApp bookstoreApp = new BookstoreApp();
        bookstoreApp.run();
    }

    private void run() {

        // Instantiate datasource and set connection string
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:postgresql://localhost:5432/bookstore");
        // Set connection credentials
        dataSource.setUsername("postgres");
        dataSource.setPassword("postgres1");

        // Create an instance of JdbcAuthorDAO
        AuthorDao authorDao = new JdbcAuthorDao(dataSource);

        // List all the authors
        System.out.println("All authors");
        List<Author> authors = authorDao.getAllAuthors();
        for (Author author : authors) {
            System.out.println(author);
        }

        // Display a single author
        System.out.println("\nAuthor Id:1");
        Author author = authorDao.getAuthor(1);
        System.out.println(author);

        // Create a new author
        System.out.println("\nCreate new author");
        Author newAuthor = new Author();
        newAuthor.setFirstName("Andre");
        newAuthor.setLastName("Norton");
        newAuthor = authorDao.createAuthor(newAuthor);
        System.out.println(newAuthor); // The authorID attribute will be displayed

        // Delete the new author using their authorId
        authorDao.deleteAuthor(newAuthor.getAuthorId());
        System.out.println("\nAuthor deleted");

    }
}
```

Note the use of the model objects, especially with the `create...()` and `update...()` methods. Not only is it more convenient to pass in the model object as a whole rather than the individual attributes as arguments, but a given instance of a model object corresponds to a row in the database, and the two must be maintained in sync.

What's also important here is returning the primary key value on `INSERT`, and updating the model object with the value in the `create...()` method. As for the `update...()` method, the model object passed in is assumed to contain all the necessary row values. In other words, the model object must be adjusted outside of the `update...()` method prior to calling the method.

Finally, the primary key attribute for a given instance of a model object is only set in the `create...()` and `mapRowTo...()` methods. That identifier is critical for keeping the model object and the database row it represents in sync with one another.

You can also see these best practices being applied in the unit tutorial which walks you through a full implementation of a DAO pattern.

## Best practices and the DAO pattern

The DAO pattern promotes many best practices and principles, some of which you're already familiar with:

-   **Encapsulation**: DAO classes contain all the logic for communicating with a database, and keep it separate from the rest of the application logic.
-   **Loose coupling**: The DAO interface abstracts away the specifics of the underlying data store, so that the application and data store have no knowledge of each other. The interface allows you to replace one implementation with another that accesses a different data source with little to no change to other code.
-   **Don't Repeat Yourself (DRY)**: Organizing your code with the DAO pattern reduces duplication of the Spring JDBC code for communicating with the database and mapping data into objects.

---

# Unit summary

In this unit, you've learned:

-   How to make a connection to a SQL database.
-   How to run SQL statements from a Java application.
-   How to use parameters to in SQL statements.
-   How to read data returned from a SQL query and map it to a Java object or variable.
-   What the DAO pattern is and why it's used.

---

# Quiz

## **DAO Pattern 1**

**Put the Java data access layers in order from highest to lowest.**

â–¤ Spring JDBC

â–¤ JDBC

â–¤ JDBC Driver

â–¤ Database

**Explanation:** `Spring JDBC` is the highest layer. It contains the two sub-component layers, `JDBC` and `JDBC Driver`. `Spring JDBC` encapsulates and abstracts-away many of the lower-level details of `JDBC` and allows you to concentrate on the application.  
  
`JDBC` manages the low-level details of communication between Java and the database, and sits between `Spring JDBC` and the `JDBC Driver`.  
  
The `JDBC Driver` performs the actual transfer of requests and responses to-and-from the database. Each driver is with a specific database.  
  
`Database` is the lowest layer.


## **DAO Pattern 2**

**The Java language doesn't come with an implementation of the `DataSource` interface.**

â—‰ True

â—‹ False

**Explanation:** True, the Java language does **_not_** come with its own implementation of the `DataSource` interface. The Apache `BasicDataSource` implementation is commonly used.


## **DAO Pattern 3**

**Which of the following classes is provided by Spring JDBC for executing SQL statements and returning results?**

â—‹ `PreparedStatement`

â—‹ `Statement`

â—‰ `JdbcTemplate`

â—‹ `SqlRowSet`

**Explanation:** Spring JDBC's `JdbcTemplate` simplifies programming JDBC and offers several methods for submitting SQL statements.


## **DAO Pattern 4**

**What value would be inserted into the `last_name` column by the following code snippet?**

```java
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);

String sqlCreatePerson = 
    "INSERT INTO person(middle_name, last_name, first_name) VALUES (?, ?, ?)";

jdbcTemplate.update(sqlCreatePerson, "Stevie", "Ray", "Vaughan");
```

â—‹ Stevie

â—‰ Ray

â—‹ Vaughan

â—‹ Stevie Ray Vaughan

**Explanation:** `"Ray"` is the second prepared statement value passed into the call to `update()` and is consequently associated with the second placeholder `last_name` column of the `INSERT` SQL statement.


## **DAO Pattern 5**

**The database username and password are required in the connection string.**

â—‹ True

â—‰ False

**Explanation:** The database username and password are _not_ required in the connection string. They're set on the DataSource using the `setUsername()` and `setPassword()` methods. And in fact, adding them to the connection string is a serious breach of security.


## **DAO Pattern 6**

**Assuming an `employee` table with the following columns:**

| **Name**    | **Type** |
| ----------- | -------- |
| employee_id | SERIAL   |
| firstname   | VARCHAR  |
| lastname    | VARCHAR  |
| date_hired  | DATE     |
| hourly      | BOOLEAN  |

**8**

```java
public class Employee {

    // Instance variables
    private String employeeID;
    private String fullname;
    private LocalDate dateHired;
    private boolean hourly;

    // Assume appropriate getters and setters

}
```

	Select all correct options

â–  `String employeeId`

â–  `String fullname`

â–¡ `LocalDate dateHired`

â–¡ `boolean hourly`

â–¡ There are no incorrect instance variables

**Explanation:** `String` is an inappropriate Java type for SQL `employee_id SERIAL`.  
  
There is no `fullname` SQL column. Multiple SQL columns such as `firstname` and `lastname` should be kept as separate instance variables in the Java class.


## **DAO Pattern 7**

**What are the features of object-oriented programming that the DAO Pattern relies upon?**

	Select all correct options

â–  Polymorphism

â–¡ Inheritance

â–  Encapsulation

â–¡ Abstraction

**Explanation:** The DAO interface layer is the polymorphic expression of its capabilities, while the data source implementation of the interface encapsulates the state and behaviors of the specific data sources.


## **DAO Pattern 8**

**Put the following steps for submitting SQL using Spring JDBC in the correct order.**

â–¤ Create `DataSource`

â–¤ Bind `DataSource` to `JdbcTemplate`

â–¤ Assign SQL statement to a `String` variable

â–¤ Submit SQL `String` using `JdbcTemplate`

â–¤ Handle values returned by submission

**Explanation:** The `DataSource` must first be created and then bound to the `JDBCTemplate.<br><br> The SQL statement string is optionally assigned to a separate` String`variable, and then passed to the`JDBCTemplate`,or the SQL statement string may passed directly as a` String`literal to`JDBCTemplate`.  
  
Once the SQL statement has been submitted, the returned values are handled.


## **DAO Pattern 9**

**Assuming an `employee` table with the following columns:**

| **Name**    | **Type** |
| ----------- | -------- |
| employee_id | SERIAL   |
| firstname   | VARCHAR  |
| lastname    | VARCHAR  |
| date_hired  | DATE     |
| hourly      | BOOLEAN  |

**What's the correct way to pull out the value of `lastname` column from a returned `SqlRowSet` named `results`?**

â—‹ `results.pullString("lastname")`

â—‹ `results.getVarChar("lastname")`

â—‰ `results.getString("lastname")`

â—‹ `results.pullVarChar("lastname")`

**Explanation:** `results.getString("lastname")` retrieves the value from the `lastname` column and passes it as a argument to `getString()` which converts the column `VARCHAR` value to a Java `String`.


## **DAO Pattern 10**

**Typically you use a `while` to handle a `SqlRowSet` containing multiple rows.**

```java
while (results.next()) {
    // Handle a row from the SqlRowSet
}
```

**Select reasons why you may want to use an `if` or `if-else` instead.**

	Select all correct options

â–  Handle the first row only

â–¡ Include additional conditions to boolean expression

â–  Test at least one row returned

â–  Special processing if zero rows returned

**Explanation:** **Handle the first row only** regardless of how many rows were returned as long as there was at least one.  
**Test at least one row returned** is similar to handling the first row only in that it guarantees at least one row was returned.  
**Special processing if zero rows returned** can be handled within the `else` of an `if-else`.

```java
if (results.next()) {
    // Handle only the first row, confirmed at least one row returned.
}
else {
    // No rows returned, perform desired special processing such throwing exception, displaying message, etc.
}
```
